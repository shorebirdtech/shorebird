// cspell:words dgst genrsa genpkey
import 'dart:convert';
import 'dart:io';
import 'dart:typed_data';

import 'package:pem/pem.dart';
import 'package:pointycastle/pointycastle.dart';
import 'package:scoped_deps/scoped_deps.dart';

/// A reference to a [CodeSigner] instance.
final codeSignerRef = create(CodeSigner.new);

/// The [CodeSigner] instance available in the current zone.
CodeSigner get codeSigner => read(codeSignerRef);

/// The format of a PEM-encoded private key.
enum PrivateKeyFormat {
  /// PKCS#8 format with header "-----BEGIN PRIVATE KEY-----".
  /// Generated by: openssl genpkey -algorithm RSA
  pkcs8,

  /// PKCS#1 format with header "-----BEGIN RSA PRIVATE KEY-----".
  /// Generated by: openssl genrsa
  pkcs1,
}

/// {@template code_signer}
/// Manages code signing operations.
/// {@endtemplate}
class CodeSigner {
  /// Signs a [message] using the provided [privateKeyPemFile] using
  /// SHA-256/RSA.
  ///
  /// This is the equivalent of:
  ///   $ openssl dgst -sha256 -sign privateKey.pem -out signature message
  ///
  /// Supports both PKCS#8 ("BEGIN PRIVATE KEY") and PKCS#1
  /// ("BEGIN RSA PRIVATE KEY") formats.
  String sign({required String message, required File privateKeyPemFile}) {
    final pemString = privateKeyPemFile.readAsStringSync();
    final (keyBytes, format) = _parsePrivateKeyPem(pemString);
    final privateKey = _RSAPrivateKeyFromBytes.from(keyBytes, format);

    final signer = Signer('SHA-256/RSA')
      ..init(true, PrivateKeyParameter<RSAPrivateKey>(privateKey));

    final signature =
        signer.generateSignature(utf8.encode(message)) as RSASignature;
    return base64.encode(signature.bytes);
  }

  /// Extracts the base64 encoded DER from a public key PEM file. The DER is
  /// simply the modulus and exponent of the public key, without information
  /// about the algorithm or or ASN1 object type identifier.
  String base64PublicKey(File publicKeyPemFile) {
    final publicKey = _RSAPublicKeyFromBytes.rsaPublicKeyFromBytes(
      _pemBytes(pemFile: publicKeyPemFile, type: PemLabel.publicKey),
    );

    final publicKeySeq = ASN1Sequence()
      ..add(ASN1Integer(publicKey.modulus))
      ..add(ASN1Integer(publicKey.exponent))
      ..encode();
    return base64.encode(publicKeySeq.encodedBytes!);
  }

  /// Reads a PEM file containing a key of type [type] and returns its contents
  /// as bytes.
  List<int> _pemBytes({required File pemFile, required PemLabel type}) {
    final privateKeyString = pemFile.readAsStringSync();
    return PemCodec(type).decode(privateKeyString);
  }

  /// Parses a PEM-encoded private key string and returns the key bytes along
  /// with the detected format.
  ///
  /// Supports both PKCS#8 and PKCS#1 formats.
  (List<int>, PrivateKeyFormat) _parsePrivateKeyPem(String pemString) {
    // Try PKCS#8 format first (BEGIN PRIVATE KEY) - natively supported.
    final pkcs8Blocks = decodePemBlocks(PemLabel.privateKey, pemString);
    if (pkcs8Blocks.isNotEmpty) {
      return (pkcs8Blocks.first, PrivateKeyFormat.pkcs8);
    }

    // Try PKCS#1 format (BEGIN RSA PRIVATE KEY).
    // The pem package only supports RFC 7468 labels and doesn't include
    // "RSA PRIVATE KEY", so we validate the label ourselves and use
    // unsafeIgnoreLabel for parsing.
    // See: https://github.com/google/dart-neats/issues/198
    if (pemString.contains('-----BEGIN RSA PRIVATE KEY-----')) {
      final blocks = decodePemBlocks(
        PemLabel.privateKey,
        pemString,
        unsafeIgnoreLabel: true,
      );
      if (blocks.isNotEmpty) {
        return (blocks.first, PrivateKeyFormat.pkcs1);
      }
    }

    throw const FormatException(
      'No valid PEM private key found. Expected "BEGIN PRIVATE KEY" (PKCS#8) '
      'or "BEGIN RSA PRIVATE KEY" (PKCS#1) format.',
    );
  }
}

extension _RSAPrivateKeyFromBytes on RSAPrivateKey {
  /// Converts RSA private key bytes to a pointycastle [RSAPrivateKey].
  ///
  /// Supports both PKCS#8 and PKCS#1 formats based on the [format] parameter.
  ///
  /// Based on https://github.com/konstantinullrich/crypton/blob/trunk/lib/src/rsa/private_key.dart
  static RSAPrivateKey from(
    List<int> privateKeyBytes,
    PrivateKeyFormat format,
  ) {
    final asn1Parser = ASN1Parser(Uint8List.fromList(privateKeyBytes));
    final topLevelSeq = asn1Parser.nextObject() as ASN1Sequence;

    final ASN1Sequence pkSeq;
    switch (format) {
      case PrivateKeyFormat.pkcs8:
        // PKCS#8: The RSA key is wrapped in an envelope, extract from
        // element[2].
        final privateKeyOctet = topLevelSeq.elements![2];
        final innerParser = ASN1Parser(privateKeyOctet.valueBytes);
        pkSeq = innerParser.nextObject() as ASN1Sequence;
      case PrivateKeyFormat.pkcs1:
        // PKCS#1: The RSA key is directly at the top level
        pkSeq = topLevelSeq;
    }

    // RSAPrivateKey structure (same for both formats at this point):
    // version, modulus, publicExponent, privateExponent, prime1, prime2, ...
    final modulus = pkSeq.elements![1] as ASN1Integer;
    final privateExponent = pkSeq.elements![3] as ASN1Integer;
    final p = pkSeq.elements![4] as ASN1Integer;
    final q = pkSeq.elements![5] as ASN1Integer;

    return RSAPrivateKey(
      modulus.integer!,
      privateExponent.integer!,
      p.integer,
      q.integer,
    );
  }
}

extension _RSAPublicKeyFromBytes on RSAPublicKey {
  /// Converts an RSA public key to a pointycastle [RSAPublicKey].
  ///
  /// Based on https://github.com/Ephenodrom/Dart-Basic-Utils/blob/45ed0a3087b2051004f17b39eb5289874b9c0390/lib/src/CryptoUtils.dart#L525-L547
  static RSAPublicKey rsaPublicKeyFromBytes(List<int> bytes) {
    final asn1Parser = ASN1Parser(Uint8List.fromList(bytes));
    final topLevelSeq = asn1Parser.nextObject() as ASN1Sequence;
    final publicKeyBitString = topLevelSeq.elements![1] as ASN1BitString;
    final publicKeyAsn = ASN1Parser(
      publicKeyBitString.stringValues as Uint8List?,
    );
    final publicKeySeq = publicKeyAsn.nextObject() as ASN1Sequence;
    final modulus = publicKeySeq.elements![0] as ASN1Integer;
    final exponent = publicKeySeq.elements![1] as ASN1Integer;

    return RSAPublicKey(modulus.integer!, exponent.integer!);
  }
}
