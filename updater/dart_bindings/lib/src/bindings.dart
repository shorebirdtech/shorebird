// This entire file could be easily autogenerated.
// Probably https://pub.dev/packages/ffigen would work.

import 'dart:ffi' as ffi;

import 'package:ffi/ffi.dart';

// This must be kept in sync with the C struct in updater.h.
// Including *in the same order* as the C struct.
class AppParameters extends ffi.Struct {
  external ffi.Pointer<Utf8> channel;
  // ignore: non_constant_identifier_names
  external ffi.Pointer<Utf8> app_id;
  // ignore: non_constant_identifier_names
  external ffi.Pointer<Utf8> base_version;
  // ignore: non_constant_identifier_names
  external ffi.Pointer<Utf8> update_url;
  // ignore: non_constant_identifier_names
  external ffi.Pointer<ffi.Pointer<Utf8>> original_libapp_paths;
  @ffi.Int8()
  // ignore: non_constant_identifier_names
  external int original_libapp_paths_size;
  // ignore: non_constant_identifier_names
  external ffi.Pointer<Utf8> vm_path;
  // ignore: non_constant_identifier_names
  external ffi.Pointer<Utf8> cache_dir;

  static ffi.Pointer<AppParameters> allocate({
    required String appId,
    required String version,
    required String channel,
    required String? updateUrl,
    required List<String> libappPaths,
    required String libflutterPath,
    required String cacheDir,
  }) {
    var config = calloc<AppParameters>();
    config.ref.app_id = appId.toNativeUtf8();
    config.ref.base_version = version.toNativeUtf8();
    config.ref.channel = channel.toNativeUtf8();
    if (updateUrl != null) {
      config.ref.update_url = updateUrl.toNativeUtf8();
    }
    config.ref.original_libapp_paths = calloc<ffi.Pointer<Utf8>>(
      libappPaths.length,
    );

    for (var i = 0; i < libappPaths.length; i++) {
      config.ref.original_libapp_paths[i] = libappPaths[i].toNativeUtf8();
    }
    config.ref.vm_path = libflutterPath.toNativeUtf8();
    config.ref.cache_dir = cacheDir.toNativeUtf8();
    return config;
  }

  static void free(ffi.Pointer<AppParameters> config) {
    calloc.free(config.ref.app_id);
    calloc.free(config.ref.base_version);
    calloc.free(config.ref.channel);
    calloc.free(config.ref.update_url);
    // Free all paths in original_libapp_path.
    for (var i = 0; i < config.ref.original_libapp_paths_size; i++) {
      calloc.free(config.ref.original_libapp_paths[i]);
    }
    calloc.free(config.ref.original_libapp_paths);
    calloc.free(config.ref.vm_path);
    calloc.free(config.ref.cache_dir);
    calloc.free(config);
  }
}

typedef _GetBoolFunc = ffi.Bool Function();
typedef GetBool = bool Function();

typedef _GetStringFunc = ffi.Pointer<Utf8> Function();
typedef GetString = ffi.Pointer<Utf8> Function();

typedef _GetVoidFunc = ffi.Void Function();
typedef GetVoid = void Function();

typedef _SBInitFunc = ffi.Void Function(ffi.Pointer<AppParameters> config);
typedef SBInit = void Function(ffi.Pointer<AppParameters> config);

typedef _FreeStringFunc = ffi.Void Function(ffi.Pointer<Utf8> str);
typedef FreeString = void Function(ffi.Pointer<Utf8> str);

class UpdaterBindings {
  final ffi.DynamicLibrary library;

  late SBInit init;
  late GetBool checkForUpdate;
  late GetString activeVersion;
  late GetString activePath;
  late FreeString freeString;
  late GetVoid update;

  UpdaterBindings(this.library) {
    // None of these call back into Dart, so they're all safely "isLeaf: true".
    init = library.lookupFunction<_SBInitFunc, SBInit>('shorebird_init',
        isLeaf: true);
    activeVersion = library.lookupFunction<_GetStringFunc, GetString>(
        'shorebird_active_version',
        isLeaf: true);
    activePath = library.lookupFunction<_GetStringFunc, GetString>(
        'shorebird_active_path',
        isLeaf: true);
    freeString = library.lookupFunction<_FreeStringFunc, FreeString>(
        'shorebird_free_string',
        isLeaf: true);
    checkForUpdate = library.lookupFunction<_GetBoolFunc, GetBool>(
        'shorebird_check_for_update',
        isLeaf: true);
    update = library.lookupFunction<_GetVoidFunc, GetVoid>('shorebird_update',
        isLeaf: true);
  }
}
